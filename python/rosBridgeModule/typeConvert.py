# H2020 ESROCOS Project
# Company: GMV Aerospace & Defence S.A.U.
# Licence: GPLv2

'''
This module transforms between ASN.1 and ROS types. It provides 
functions to find the equivalent ROS type, and to convert the values 
at runtime. 
The runtime conversion uses the Python infrastructure generated by 
TASTE for GUI components. TASTE generates functions to convert between 
a textual representation of ASN.1 named GSER and the internal 
representation of the type. This module provides functions to convert 
from rospy types to GSER.
'''

import re
import rospy, rosmsg, rospkg, genpy
from importlib import import_module


# Words that need to be replaced in ASN.1 field names
TasteForbiddenKeywords = [
    "active", "adding", "all", "alternative", "and", "any", "as", "atleast", "axioms", "block", "call", "channel", "comment", "connect", "connection", "constant", "constants", "create", "dcl", "decision", "default", "else", "endalternative", "endblock", "endchannel", "endconnection", "enddecision", "endgenerator", "endmacro", "endnewtype", "endoperator", "endpackage", "endprocedure", "endprocess", "endrefinement", "endselect", "endservice", "endstate", "endsubstructure", "endsyntype", "endsystem", "env", "error", "export", "exported", "external", "fi", "finalized", "for", "fpar", "from", "gate", "generator", "if", "import", "imported", "in", "inherits", "input", "interface", "join", "literal", "literals", "macro", "macrodefinition", "macroid", "map", "mod", "nameclass", "newtype", "nextstate", "nodelay", "noequality", "none", "not", "now", "offspring", "operator", "operators", "or", "ordering", "out", "output", "package", "parent", "priority", "procedure", "process", "provided", "redefined", "referenced", "refinement", "rem", "remote", "reset", "return", "returns", "revealed", "reverse", "save", "select", "self", "sender", "service", "set", "signal", "signallist", "signalroute", "signalset", "spelling", "start", "state", "stop", "struct", "substructure", "synonym", "syntype", "system", "task", "then", "this", "timer", "to", "type", "use", "via", "view", "viewed", "virtual", "with", "xor", "end", "i", "j", "auto", "const",
    "abstract", "activate", "and", "assume", "automaton", "bool", "case", "char", "clock", "const", "default", "div", "do", "else", "elsif", "emit", "end", "enum", "every", "false", "fby", "final", "flatten", "fold", "foldi", "foldw", "foldwi", "function", "guarantee", "group", "if", "imported", "initial", "int", "is", "last", "let", "make", "map", "mapfold", "mapi", "mapw", "mapwi", "match", "merge", "mod", "node", "not", "numeric", "of", "onreset", "open", "or", "package", "parameter", "pre", "private", "probe", "public", "real", "restart", "resume", "returns", "reverse", "sensor", "sig", "specialize", "state", "synchro", "tel", "then", "times", "transpose", "true", "type", "unless", "until", "var", "when", "where", "with", "xor",
    "open", "close", "flag",
    "name", "size", "data", "range"
]


def find_ros_type(rospack, asn1Type):
    '''
    Finds the ROS type corresponding to an ASN.1 type. 
    Receives a rospack object with the ROS packages information and
    the name of the ASN.1 type. Returns (found, package, message), 
    where found is a bool indicating success or failure, and if True, 
    then package and message are  the ROS package name and message 
    names corresponding to the input asn1Type.
    '''
    
    packages = [pkg for pkg, _ in rosmsg.iterate_packages(rospack, rosmsg.MODE_MSG)]
    
    for pkg in packages:
         for msg in rosmsg.list_msgs(pkg, rospack):
             if type_name_matches(asn1Type, msg):
                 return (True, pkg, msg)
             
    return (False, None, None)


def type_name_matches(asn1Type, msg):
    '''
    Checks if an ASN.1 type name matches a ROS message type, considering
    the name conversion between ASN.1 and ROS types.
    '''
    candidate = msg.replace('-', '_')
    candidate = candidate.replace('/', '_')
    candidate = str.upper(candidate[0]) + candidate[1:]
    return candidate == asn1Type


def rosmsg_to_gser(msgObj):
    '''
    Serialize a ROS message object in ASN.1 GSER format.
    '''
    if not hasattr(msgObj, '__slots__'):
        raise TypeError('Cannot serialize message: no slots found in {}'.format(msgObj))
    
    elements = []
    for slot in msgObj.__slots__:
        try:
            value = value_to_gser(getattr(msgObj, slot))
        except TypeError as ex:
            raise TypeError('Error serializing slot {}: {}.'.format(slot, str(ex)))

        elements.append('{} {}'.format(slotRosToGser(slot), value))
    
    return '{{ {} }}'.format(', '.join(elements))
        

def value_to_gser(value):
    '''
    Serialize a value of a ROS message slot.
    '''
    if isinstance(value, (int, long, float)):
        return str(value)

    if isinstance(value, bool):
        return str(value).upper()

    if isinstance(value, (str, bytes)):
        return '"{}"'.format(value)

    elif isinstance(value, (genpy.rostime.Time, genpy.rostime.Duration, rospy.Time, rospy.Duration)):
        return '{{ secs {}, nsecs {} }}'.format(str(value.secs), str(value.nsecs))
    
    elif isinstance(value, list):
        return '{{ {} }}'.format(', '.join(map(value_to_gser, value)))
        
    elif isinstance(value, (genpy.message.Message, rospy.Message)):
        return rosmsg_to_gser(value)

    else:
        raise TypeError('Cannot serialize to GSER')


def gser_to_rosmsg(gser, rosObj):
    '''
    Initialize a ROS message object with the data read from a GSER
    textual representation.
    '''
    if not hasattr(rosObj, '__slots__'):
        raise TypeError('Object does not seem to be a ROS message: {}.'.format(rosObj))
    
    match = re.match('^\s*\{\s*(.*)\s*\}\s*$', gser)
    if match:
        content = match.group(1)
        gserSlots = split_slots(content)

        for i in range(0, len(rosObj.__slots__)):
            slot = rosObj.__slots__[i]
            slotType = rosObj._slot_types[i]
            
            match = re.match('^\s*{}\s*(.*)\s*$'.format(slotRosToGser(slot)), gserSlots[i])
            if match:
                value = match.group(1)
                setattr(rosObj, slot, gser_to_value(value, slotType))
            else:
                raise ValueError('Cannot parse value for slot {} in {}.'.format(slot, gserSlots[i]))
    else:
        raise ValueError('Unexpected GSER format: {}.'.format(gser))
        
    return rosObj


def split_slots(txt):
    '''
    Splits a string: 'slot_name_1 slot_value_1, slot_name_2 slot_value_2, ...',
    taking into account that values can contain braces and commas.
    '''
    slots = []
    braces = 0
    slt = ''
    
    for c in txt:
        if braces == 0 and c == ',':
            slots.append(slt)
            slt = ''
        elif c == '{':
            braces += 1
            slt += c
        elif c == '}':
            braces -= 1
            slt += c
        else:
            slt += c

    slots.append(slt)
    
    return slots


def gser_to_value(gser, typeName):
    '''
    Initializes an object from a value in GSER textual representation.
    '''
    gser = gser.strip()
    
    match = re.match('(.*)\[.*\]', typeName)
    if match:
        # Array type
        elemType = match.group(1)
        
        # Remove braces
        match = re.match('^\{\s*(.*)\s*\}$', gser)
        if match:
            content = match.group(1)
        else:
            raise ValueError("GSER string {} doesn't match {} array".format(gser, typeName))

        return map(lambda elemStr: gser_to_value(elemStr, elemType), content.split(','))
        
    else:
        # Scalar type
        if typeName in ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32']:
            return long(gser)
        elif typeName in ['int64', 'uint64']:
            return long(gser)
        elif typeName in ['float32', 'float64']:
            return float(gser)
        elif typeName == 'bool':
            return bool(gser.capitalize())
        elif typeName == 'string':
            return str(gser.strip('"'))
        elif typeName == 'time':
            obj = genpy.message.Time()
            return gser_to_rosmsg(gser, obj)
        elif typeName == 'duration':
            obj = genpy.message.Duration()
            return gser_to_rosmsg(gser, obj)
        else:
            match = re.match('(.+)/(.+)', typeName)
            if match:
                pkgName = match.group(1)
                msgName = match.group(2)
                obj = get_ros_message_object(typeName)
                return gser_to_rosmsg(gser, obj)
            else:
                raise ValueError('Unexpected slot type name {}'.format(typeName))


def get_ros_message_object(typeName):
    '''
    Create a default ROS message object of the type defined by the 
    given package and message names. 
    '''
    match = re.match('(.+)/(.+)', typeName)
    if match:
        pkgName = match.group(1)
        msgName = match.group(2)
        mod = import_module('{}.msg'.format(pkgName))
        obj = eval('mod.{}()'.format(msgName))
        return obj
    else:
        raise ValueError('Unexpected ROS type name {}'.format(typeName))



def slotGserToRos(asn1FieldName):
    '''
    Rename an ASN.1 field name to ROS message field name, considering
    '-' substitution and forbidden words.
    '''
    name = asn1FieldName.replace('-', '_')
    
    if name.endswith('_value'):
        trimmed = name[0:name.rfind('_value')]
        if trimmed in TasteForbiddenKeywords:
            return trimmed
    
    return name


def slotRosToGser(rosSlotName):
    '''
    Rename an ROS message field name to ASN.1 field name, considering
    '-' substitution and forbidden words.
    '''
    name = rosSlotName.replace('_', '-')

    if name in TasteForbiddenKeywords:
        return name + '-value'
    
    return name
